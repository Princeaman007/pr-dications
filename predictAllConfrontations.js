// predictAllConfrontations.js
const mongoose = require("mongoose");
const Match = require("./models/Match");
require("dotenv").config();

// Connexion MongoDB avec gestion d'erreur
mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log("‚úÖ Connect√© √† MongoDB"))
  .catch(err => {
    console.error("‚ùå Erreur MongoDB:", err.message);
    process.exit(1);
  });

/**
 * Normalise une paire d'√©quipes pour cr√©er une cl√© unique
 * @param {string} teamA - Premi√®re √©quipe
 * @param {string} teamB - Deuxi√®me √©quipe
 * @returns {string} Cl√© normalis√©e pour la paire d'√©quipes
 */
const normalizePair = (teamA, teamB) => {
  return [teamA, teamB].sort().join("|#|");
};

/**
 * Ex√©cute les pr√©dictions pour toutes les confrontations possibles
 */
const runPredictionForAll = async () => {
  try {
    console.log("üîç R√©cup√©ration des matchs termin√©s...");
    const matches = await Match.find({ status: "FINAL" });
    console.log(`‚úÖ ${matches.length} matchs trouv√©s.`);
    
    // Regrouper les matchs par paires d'√©quipes
    const pairMap = {}; // { "teamA|#|teamB": [matches...] }
    for (const match of matches) {
      const key = normalizePair(match.homeTeam, match.awayTeam);
      if (!pairMap[key]) pairMap[key] = [];
      pairMap[key].push(match);
    }
    
    console.log(`üìä Analyse de ${Object.keys(pairMap).length} confrontations diff√©rentes...`);
    
    // Tableau pour stocker les r√©sultats avant affichage
    const results = [];
    
    // Traiter chaque paire d'√©quipes
    for (const key of Object.keys(pairMap)) {
      const matchList = pairMap[key];
      const [teamA, teamB] = key.split("|#|");
      
      // V√©rifier qu'il y a au moins 2 matchs pour que l'analyse soit pertinente
      if (matchList.length < 2) {
        continue; // Passer √† la confrontation suivante
      }
      
      const playerStats = {};
      const synergyMap = {};
      
      // Calculer la date du match le plus r√©cent
      const latestMatchDate = new Date(Math.max(...matchList.map(m => new Date(m.date))));
      
      // Pond√©ration bas√©e sur la r√©cence
      for (const match of matchList) {
        const matchDate = new Date(match.date);
        // Diff√©rence en jours, maximum 365 jours
        const daysSince = Math.min(365, Math.floor((latestMatchDate - matchDate) / (1000 * 60 * 60 * 24)));
        // Facteur de pond√©ration: 1.0 pour match r√©cent, diminue avec l'anciennet√©
        const weightFactor = Math.max(0.5, 1 - (daysSince / 365));
        
        const scorers = match.scorers || [];
        const activeScorers = scorers.filter(s => s.goals > 0);
        
        // Mise √† jour des statistiques des joueurs
        for (const scorer of scorers) {
          const name = scorer.name;
          if (!playerStats[name]) {
            playerStats[name] = { goals: 0, assists: 0, appearances: 0, weightedScore: 0 };
          }
          
          const goals = scorer.goals || 0;
          const assists = scorer.assists || 0;
          
          playerStats[name].goals += goals;
          playerStats[name].assists += assists;
          playerStats[name].appearances++;
          playerStats[name].weightedScore += (goals + assists * 0.5) * weightFactor;
        }
        
        // Analyse des synergies entre buteurs
        for (let i = 0; i < activeScorers.length; i++) {
          for (let j = i + 1; j < activeScorers.length; j++) {
            const pair = [activeScorers[i].name, activeScorers[j].name].sort();
            const duoKey = `${pair[0]}|${pair[1]}`;
            synergyMap[duoKey] = (synergyMap[duoKey] || 0) + weightFactor;
          }
        }
      }
      
      // Calculer le score total de buts pour chaque √©quipe
      const teamAGoals = matchList.reduce((sum, match) => 
        sum + (match.homeTeam === teamA ? match.homeScore : match.awayScore), 0);
      
      const teamBGoals = matchList.reduce((sum, match) => 
        sum + (match.homeTeam === teamB ? match.homeScore : match.awayScore), 0);
      
      // Trier les buteurs par score pond√©r√©
      const sortedScorers = Object.entries(playerStats)
        .map(([name, stats]) => ({
          name,
          weightedScore: stats.weightedScore,
          rawScore: stats.goals + stats.assists * 0.5,
          ...stats
        }))
        .sort((a, b) => b.weightedScore - a.weightedScore)
        .slice(0, 3);
      
      // Trouver les meilleures synergies
      const topPairs = Object.entries(synergyMap)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 1)
        .map(([key, count]) => ({
          pair: key.split("|"),
          matchesTogether: Math.round(count * 10) / 10
        }));
      
      // Stocker les r√©sultats pour cette confrontation
      results.push({
        teamA,
        teamB,
        matchCount: matchList.length,
        teamAGoals,
        teamBGoals,
        topScorers: sortedScorers,
        synergy: topPairs.length > 0 ? topPairs[0] : null
      });
    }
    
    // Trier les r√©sultats par nombre de matchs (confrontations les plus fr√©quentes d'abord)
    results.sort((a, b) => b.matchCount - a.matchCount);
    
    // Afficher les r√©sultats
    for (const result of results) {
      console.log(`\nüìä ${result.teamA} vs ${result.teamB} (${result.matchCount} matchs)`);
      console.log(` Score global: ${result.teamA} ${result.teamAGoals}-${result.teamBGoals} ${result.teamB}`);
      
      if (result.topScorers.length > 0) {
        console.log(` Meilleurs buteurs:`);
        result.topScorers.forEach((p, i) => {
          const efficiency = (p.goals / p.appearances).toFixed(2);
          console.log(`  ${i + 1}. ${p.name} ‚Äî ${p.goals} buts, ${p.assists} assists (${efficiency} buts/match)`);
        });
      }
      
      if (result.synergy) {
        const p = result.synergy;
        console.log(` ü§ù Duo: ${p.pair[0]} + ${p.pair[1]} (${p.matchesTogether} matchs avec buts ensemble)`);
      }
    }
    
    console.log(`\n‚úÖ Analyse termin√©e pour ${results.length} confrontations.`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de l'analyse: ${error.message}`);
  } finally {
    // Fermeture de la connexion dans tous les cas
    await mongoose.connection.close();
    console.log("\nüîå Connexion MongoDB ferm√©e");
  }
};

// Ex√©cution du script
runPredictionForAll();